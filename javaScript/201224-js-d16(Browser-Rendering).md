# 브라우저 렌더링 

Node.js의 등장으로 인해 서버 사이드 애플리케이션 개발에도 쓰이게 되었지만 여전히 가장 많이 사용되는 분야는 웹페이지/애플리케이션 client-side.

![browser rendering](https://poiemaweb.com/assets/fs-images/38-1.png)

1. HTML, CSS, 자바스크립트, 이미지, 폰트, 등 렌더링에 필요한 리소르를 요청하고 서버로부터 응답
2. HTML, CSS 를 파싱해서 DOM 과 CSSOM을 생성한뒤 이 둘을 결합하여 렌더 트리를 생성
3. 자바스크립트를 파싱하여 Abstract Syntax Tree를 생성하고 바이트코드로 변환후 실행 (DOM, CSSOM 을 변경할수 있음) 
4. 렌더 트리를 기반으로 HTML 요소의 레이아웃을 계산한뒤 화면에 HTML요소를 렌더링

## 요청과 응답

- 브라우저의 핵심기능은 리소스를 서버에 요청하고 응답받아 브라우저에 시각적으로 렌더링하는것

- 서버에 요청을 할때는 URI를 통해서

![URI](https://poiemaweb.com/assets/fs-images/38-2.png)

- 서버는 루트 요청에 암묵적으로 index.html을 응답하도록 기본 설정 <br>
www.google.com -> www.google.com/index.html

## HTTP 1.1 , HTTP 2.0

- HTTP 1.1은 커넥션당 하나의 요청과 응답만 처리
- 여러개의 요청을 한번에 요청하거나 응답할수 없음
- 따라서 요청할 리소스의 개수에 비해 응답 시간도 증가

- Http 2.0는 여러개의 요청과 응답이 가능
- 따라서 로드 속도가 약 2배 정도 증가

## HTMl 파싱과 DOM 

- HTML 문서를 시각적인 픽셀로 렌더링하기 위해 브라우저가 이해할수 있는 객체형식으로 변환후 메모리에 저장해야함

- 응답받은 HTML을 파싱을 통해 브라우저가 이해할수 있는 자료구조인 Document Object Model(DOM)을 생성

## CSS 파싱과 CSSOM 생성

렌더링 엔진은 HTML을 파싱하여 DOM을 생성하나가다 CSS를 로드하는 link 태그나 style태그를 만날시 DOM 생성을 일시 중단하고 CSS 파싱 과정을 거침

byte -> 문자 -> token -> node -> CSSOM

## 렌더 트리 생성

- 생성된 DOM과 CSSOM은 렌더링을 위해 렌더 트리의 형식으로 결합이 됨

- 렌더 트리는 HTML 요소의 위치와 크기를 계산하는데 사용되고 브라우저 화면에 픽셀을 렌더링하기 위해 사용됨

- 레이아웃 계산과 페인팅은 다음과 같은 경우 다시 실행 (리플로우/리페인트)
    - 자바스크립트에 의해 노드 추가/삭제
    - 뷰포트 크기 변경
    - HTML 요소의 레이아웃/크기/위치 등 스타일 변경

## 자바스크립트 파싱과 실행

- 자바스크립트 파싱과 실행은 브라우저 렌더링 엔진이 아닌 자바스크립트 엔진이 처리.
- 렌더링 엔진이 HTML 과 CSS를 파싱하여 DOM/CSSOM을 만들듯이 js 엔진은 자바스크립트를 해석하서 Abstract Syntax Tree를 생성
- AST 기반으로 인터프리터가 실행할수 있는 바이트코드를 생성하여 실행

## 자바스크립트 파싱에 의한 HTML 파싱 중단

- 브라우저는 위에서 아래로 (순차적으로) HTML, CSS, JS를 파싱하고 실행
- 따라서 script 태그의 위치가 중요
- DOM API를 사용해야할때 DOM 생성이 완료되지 않은 상태라면 문제가 발생

## 자바스크립트 defer/async

- 위 문제의 해결책으로 src 어트리뷰튜가 있는 script태그에 사용가능
- 파싱과 외부의 자바스크립트 파일의 로드가 비동기적으로 진행 
- async - 자바스크립트 파싱과 실행은 로드가 완료된 직후 진행
- defer - 파싱이 완료된 직후 (DOM이 만들어진뒤) 진행 IE10 ^