# let, const 키워드와 블록 레벨 스코프

## 변수의 중복 선언 

var 키워드로 선언한 변수는 중복 선인이 가능.
중복 선언시,
초기화문이 있는 변수 선언문은 var 키워드가 없는 것처럼 동작 
초기화문이 없는 변수 선언문은 무시

```javascript
var x = 5;
var x = 10; //x에 5라는 값이 이미 할당되어 있다고 해도 키워드를 무시하고 x의값을 재할당해줌
var x; //초기화문이 없기 때문에 무시
```

### 함수 레벨 스코프

var 키워드로 선언한 변수는 함수의 코드블록만을 지역 스코프로 인정하기 때문에
함수 외부에서 선언한 변수는 모두 전역변수가 됨.

if문 내에 있는 변수는 if문 내부에서만 유효하지 않고 밖에서도 유효함.

### let 키워드

- var 키워드의 단점을 보안하기 위해 es6에서 let 과 const를 도입함.
let 키워드로 이름이 같은 변수를 중복 선언하면 문법 에러가 발생함.

```javascript
let num = 3;
let num = 6; //syntax error 
```

- var와 달리 모든 코드 블록을 지역 스코프로 인정하는 블록 레벨 스코프를 따름.
- let 키워드로 선언한 변수는 선언 단계와 초기화 단계가 분리되어 진행 (선언은 var와 마찬가지로 런타임전에 실행되지만 초기화는 선언문에 도달했을때 실행됨).
- 초기화 단계이전에 변수에 접근하면 참조에러가 발생함 (스코프의 시점부터 초기화 단계 시점까지을 일시적 사각지대라고 함)
- 호이스팅이 발생하지 않는것처럼 동작하지만 초기화가 안되서 참조를 못할뿐 
호이스팅 자체는 일어남

## const 키워드

- 상수를 선언하기 위해 사용
- const 키워드로 선언한 변수는 반드시 선언과 동시에 초기화를 해줘야함
- 재할당이 금지됨 (재할당시 타입에러)
- 일반적으로 상수 이름은 대문자로 선언해 명확히 명시
- 재할당을 금지할뿐 불변을 의미 하진 않음
- 객체의 프로퍼티 동적 생성,삭제를 통해 객체를 변경할수 있음.


- es6문법을 사용시 var키워드는 사용하지 않음
- 변수 선언에는 기본적으로 const를 사용
- 재할당이 필요한 경우 let 키워드를 사용
- 변경이 발생하지 않고 읽기 전용으로 사용하는 원시값과 객체는 const 사용

# 프로퍼티 어트리뷰트

내부 슬롯/메서드 - 자바스크립트 엔진의 알고리즘을 설명하기 위해 사용하는 의사 프로퍼티와 메서드

- js 엔진은 프로퍼티를 생성할때 프로퍼티의 상태를 나타내는 어트리뷰트를 기본값으로 자동 정의

- 프로퍼티 상태 - value, writable, enumerable, configurable

- 프로퍼티 디스크립터 객체 - 프로퍼티 어트리뷰터 정보를 제공해줌

```javascript
  const person = {
    name: 'lee'
  }
  console.log(Object.getOwnPropertyDescriptor(person, 'name')) //{value: "lee', writable: true, enumerable: true, confirgurable: true } (데이터 프로퍼티)
```

## 데이터 프로퍼티와 접근자 프로퍼티

- 데이터 프로퍼티 - 키와 값으로 구성된 일반적인 프로퍼티
 
- 접근자 프로퍼티 - 자체적으로 값을 갖지 않고 다른 데이터 프로퍼티의 값을 읽거나 저장할때 호출되는 접근자 함수로 구성된 프로퍼티

*자세한 내용은 https://poiemaweb.com/fastcampus/property-definition poimer 테이블 참조

## 프로퍼티 정의

- 새로운 프로퍼티를 추가하면서 프로퍼티 어트리뷰트를 명시적으로 정의하거나 재정의 (값을 갱신가능, 열거, 재정의 가능하도록 할것인지)

```javascript
Object.defineProperty(객체, '프로퍼티 키' , {
  value: '프로퍼티 값',
  writable: true,
  enumerable: true,
  configurable: true
});
```

# 객체 변경 방지

객체는 변경 가능한값이기 때문에 재할당 없이 변경이 가능함.
이러한 변경을 방지하기 위해 다양한 메서드가 존재함

객체 확장 금지 - `Object.preventExtensions` <br> 
- 프로퍼티 추가 불가능
- 확장 가능한 객체인지 여부는 `Object.isExtensible`을 통해 확인 <br>

객체 밀봉 - `Object.seal` 

- 읽기와 쓰기만 가능
- 밀봉 여부는 `Object.isSealed`로 확인
<br>

객체 동결 - `Object.freeze`(프로퍼티 값 읽기만 가능)

- 동결 여부는 `Object.isFrozen` 로 확인
- 중첩 객체까지 동결한순 없음



