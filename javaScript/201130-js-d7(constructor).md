# 생성자 함수에 의한 객체 생성

## Object 생성자 함수

- `new` 연산자 + `Object` 생성자 함수 = 빈 객체
 ```javascript
  const animal = new Object(); 
  //객체 리트럴을 사용해 만든 객체와 마찬가지로 동적으로 프로퍼티를 추가해줄수있음
  animal.name = 'tommy';
 ``` 

 생성자 함수란? 

 - new 연산자와 함께 호출해 객체를 생성하는 함수. 생성자 함수에 의해 만들어진 객체는 <b>instance</b>

 - 단지 빈 객체를 생성하는 용도라면 더 간편한 객체 리터럴을 사용하는걸 권장

## 생성자 함수는 언제 써야하는가?

- 동일한 프로퍼티를 갖는 객체를 여러개 생성해야할 상황
- 프로퍼티 <b>구조</b>가 동일안 객체를 여러개 생성
- 객체의 프로퍼티는 다를수 있지만 메서드의 내용은 동일한 상황이 많기 때문에 매번 같은 프로퍼티와 메서드를 기술하지 않기 위해 

## 생성자 함수 사용

`this` - 자기 참조 변수로 , 가르키는 값은 호출 방식에 따라 동적으로 결정

- 일반 함수 - 전역객체
- 메서드에서 호출 - 메서드를 호출한 객체
- 생성자 함수에서 호출 - 생성자 함수가 생성할 인스턴스

```javascript
function foo() { 
  console.log(this);
}

// 일반적인 함수로서 호출
// 전역 객체는 브라우저 환경에서는 window, Node.js 환경에서는 global을 가리킨다.
foo(); // window

// 메서드로서 호출
const obj = { foo };
obj.foo(); // obj - 메서드를 호출한 객체

// 생성자 함수로서 호출 
const inst = new foo(); // inst - 생성자 함수가 생성할 인스턴스
```

### 인스턴스 생성과 this 바인딩

  - 암묵적으로 빈 객체가 생성
  - 생성된 빈 객체(인스턴스)는 this에 바인딩됨

### 인스턴스 초기화

- this에 바인딩 되어있는 인스턴스를 초기화 함
- 일반적으로 생성자 함수가 인수로 전달받은 초기값을 인스턴스 프로퍼티에 할당하여 초기화하거나 고정값 할당

### 인스턴스 반환

- 내부의 모든 처리가 끝난후 인스턴스가 바인딩된 this를 반환
- return을 안써주면 암묵적으로 this를 반환하지만 객체를 명시적으로 반환값으로 내보낼경우 this가 아닌 객체가 반환됨 (원시값은 무시)

## 내부 메서드 [[Call]] 과 [[Construct]]

- 함수는 일반 객체와 달리 호출을 할수 있음. 함수가 호출이 가능한 이유는 일반 객체가 가지고 있는 내부 슬롯/내부 메서드 외에도 [[Environment]](내부 슬롯)  [[Call]] 과 [[Construct]]같은 내부 메서드를 추가적으로 가지고 있기 때문

[[Call]]을 갖는 객체는 callable 즉 호출가능한 객체고 [[Construct]]는 생성자 함수로 호출할수 있는 함수.

따라서 모든 함수는 [[Call]]이라는 내부 메서드를 가지고있지만 모든 함수 객체는 생성자 함수로 호출할수 있는게 아니기 때문에 [[Construct]]가 없을수도 있음.

## constructor와 non-contructor 구분하기

- constructor - 함수 선언문, 함수 표현식, 클래스
- non-constructor - 메서드, 화살표 함수

```javascript
const arrow = () => {};

new arrow(); // 화살표함수는 constructor로 구분되지 않기 때문에 [[Construct]] 내부 메서드가 없어 타입에러가 발생  
```

함수 선언문, 함수 표현식, 클래스로 정의된 함수는 모두 [[Call]] 과 [[Construct]] 내부 메서드가 있기때문에 그냥 일반 함수로 호출도 가능하고 new 연산자를 사용하면 생성자 함수로도 사용될수 있다.

이런식으로 둘다 사용이 될수 있기 때문에 Pascal Case를 사용해서 최대한 함수가 생성자 함수로 쓰인다는 의도를 명확하게 해주는편이다. 

만약의 실수를 대비해서 es6에서 지원하는 new.target을 쓸수도 있음.(IE에서는 지원하지 않음)

```javascript
function Circle(radius) {
  if (!new.target) {
    // new 연산자와 함께 생성자 함수를 재귀 호출하여 생성된 인스턴스를 반환할수 있음
    // 이경우 new 연산자를 빼먹고 호출을 한다고 해도 생성자 함수로 작동을 하게됨
    return new Circle(radius);
  }

  ... 내부 동작 생략
  }

  const circle = Circle(5);

```
스코프 세이프 생성자 패턴(scope-safe constructor)를 사용한 방법

```javascript
//new 연산자와 호출되지 않을 경우 this 는 전역객체를 가르키고 Circle로 생성된 인스턴스가 아니기 때문에 false로 평가, 부정논리연산에 의해 아닐때 if문이 실행해서 new를 붙힌상태로 재귀호출
 if (!(this instanceof Circle)) {
    // new 연산자와 함께 호출하여 생성된 인스턴스를 반환한다.
    return new Circle(radius);
  }
```