# 클래스

es6에서 도입되어 기존 프로토타입 기반 객체지향 프로그래밍보다 클래스 기반 객체지향 프로그래밍 언어와 흡사한 객체 생성 메커니즘을 제시

생성자 함수와 차이점. 클래스는..

1. new 연산자 없이 사용을 하면 error가 발생
2. 상속을 지원하는 extends 와 super 키워드 제공 (상속 관계 구현을 더 간결하고 명료하게 함)
3. 호이스팅이 발생하지 않는것처럼 동작
4. 클래스내 모든 코드는 strict mode가 적용되어 동작
5. 클래스의 construct, 프로토타입 메서드, 정적메서드는 모드 프로퍼티 attribute `[[Enumerable]]`의 값이 false

## 클래스의 정의

클래스는 class 키워드를 사용하여 정의 (Pascal 케이스를 사용하는게 일반적이나 에러는 발생시키지 않음)

```javascript
class Person {}

//익명
const Person = class {};
//기명
const Person = class MyClass {};
```

클래스는 값처럼 사용할수 있는 일급객체이기 때문에 위와 같이 표현식으로 정의가 가능함
클래스에서 정의 가능한 메서드 = constructor, 프로토타입 메서드, 정적메서드

![클래스 vs 생성자함수](https://poiemaweb.com/assets/fs-images/25-1.png)

출처: https://poiemaweb.com/fastcampus/class

## 클래스 호이스팅

클래스는 정의 이전에 참조할수 없음. 호이스팅이 발생하긴하지만 let, const 키워드로 선언된 변수처럼 호이스팅됨 ( 초기화 단계와 선언단계가 분리되어 진행됨)

## 인스턴스 생성

new 연산자와 함께 호출되어 인스턴스를 생성

```javascript
class Person {}
const min = Person(); //TypeError
```

## 메서드

- constructor 
  - 인스턴스를 생성하고 초기화하기 위한 메서드 (이름 고정)
  - 단순한 메서드로 해석되지 않고 생성한 함수 객체 코드의 일부가 됨
  - 클래스 내 한개만 존재가능 (2개이상은 syntax error)
  - 생략해도 암묵적으로 빈 constructor가 생성 = 빈 객체 생성
  - 별도의 반환문을 갖지 않음 (암묵적으로 this를 반환)
  ```javascript class Person {
    constructor(name){
      //여기서 추가한 프로퍼티는 인스턴스의 프로퍼티로 추가됨
      this.name = name;
    }
  }
  ```
- 프로토타입 메서드
  - 생성자 함수처럼 명시적으로 프로토타입 메서드에 추가하지 않아도 기본적으로 프로토타입 메서드가 됨
  - 생성자 함수와 마찬가지로 인스턴스는 프로토타입 메서드를 상속받아 사용가능

  ```javascript
    class Person {
      // 생성자
      constructor(name) {
        // 인스턴스 생성 및 초기화
        this.name = name;
      }

      // 프로토타입 메서드
      sayHi() {
        console.log(`Hi! My name is ${this.name}`);
      }
    }
  ```
- 정적 메서드
  - static을 키워드를 붙히면 정적 메서드 처럼 작동

```javascript
  static sayHi() {
    console.log('Hi!');
  }
```
